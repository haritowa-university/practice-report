\subsubsection{}
\label{sec:analysis:research:mobArch:rx}

\emph{Reactive Extensions} --- набор средств и \gls{api}, позволяющие императивным языкам программирования использовать концепции реактивного программирования и потоки данных независимо от того, являются ли потоки синхронными или асинхронными. \cite{wiki:rx}

\gls{rx} объединяет лучшие идеи паттерна Observer, Iterable и функционального программировния. Парадигма дополняет паттерн Observer, добавляет набор операторов для декларативного описания трансформации и композиции потоков, абстрагируя вопросы синхронизации, потокобезопасности.

Одной из важнейших гарантий \gls{rx} является порядок, в котором подписчик получит данные. Observer обрабатывает каждое событие по порядку, не более одного за раз, если события успевают поступать быстрее, чем подписчик их потребляет -- события ставятся в очередь или откидываются.

Основным примитивом \gls{rx} является \emph{\gls{observable}}. Observable является идеальным способом рассылки асинхронных событий.

\begin{table}[h!]
\caption{Разные способы получения значений}
\label{theory:archeticture:rx:call}
\centering
\begin{tabularx}{\textwidth}{ |X|X|X| } 
 \hline
  & \emph{Одно значение} & \emph{Несколько значений} \\ 
 \hline
 \emph{Синхронно} & T getData() & Iterable<T> getData() \\ 
 \hline
 \emph{Асинхронно} & Future<T> & Observable<T> getData() \\ 
 \hline
\end{tabularx}
\end{table}

Создатели \gls{rx} предлагают\cite{reactivex:introduction} рассматривать \gls{observable} как эквивалент Iterable с моделью push(данные приходят, а не запрашиваются потребителем). В таблице \ref{theory:archeticture:rx:iterable-observable} рассмотрены аналогичные возможности Iterable и \gls{observable}

\begin{table}[h!]
\caption{Сравнение Observable и Iterable}
\label{theory:archeticture:rx:iterable-observable}
\centering
\begin{tabularx}{\textwidth}{ |X|X|X| } 
 \hline
 \emph{Событие} & \emph{Iterable(pull)} & \emph{Obsevable(push)} \\ 
 \hline
 \emph{Получение данных} & T next() & onNext(T) \\ 
 \hline
 \emph{Ошибка} & throw & onError(Error) \\ 
 \hline
  \emph{Завершение} & !hasNext() & onCompleted() \\ 
 \hline
\end{tabularx}
\end{table}

\gls{observable} принято разделять на \emph{холодные} и \emph{горячие}. Различие заключается в том, когда \gls{observable} начинает высылать значения, когда выполняется логика подписки. Холодный \gls{observable} запускает работу при каждой подписке, следовательно высылает полный набор значений каждому подписчику. Горячий \gls{observable} начинает работу(и рассылку событий) при создании, подписчики получают только события, которые были высланы после подписки, у горячих \gls{observable} нет возможности запустить работу заново. Хорошим примером отличия горячих и холодных \gls{observable} является сетевой запрос:

\begin{itemize}
	\item Холодный \gls{observable} будет выполнять запрос при каждой новой подписке, высылая результат каждому новому подписчику;
	\item Горячий \gls{observable} отправит запрос при создании, результат получат только те подписчики, которые сформировали подписку до получения ответа от сети.
\end{itemize}

Существуют способы охладить или подогреть \gls{observable}, заставить горячий \gls{observable} высылать определённое количество последних событий всем новым подписчикам, отложить его работу до вызова метода connect.

\gls{observable} и observer являются важными компонентами \gls{rx}, но не единственными. Сами по себе они не делают ничего, кроме небольшого расширения привычного паттерна Observer, адаптированного для работы с последовательностью событий. Настоящая сила \gls{rx} приходит с так называемыми реактивными расширениями: операторами, которые позволяют трансформировать, комбинировать и манипулировать значениями, произведёнными \gls{observable}. Эти расширения позволяют декларативно компоновать асинхронные последовательности с высокой производительностью колбеков, но без побочных эффектов в виде высокой вложенности и кода-лапши.

\emph{Оператор} --- функция, которая принимает \gls{observable} своим первым аргументом и возвращает другой \gls{observable}, который является результатом некоторой трансформации элементов из первого \gls{observable}.