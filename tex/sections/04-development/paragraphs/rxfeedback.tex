\subsubsection{}
\label{sec:development:arch:ios:rxfeedback}

Многие процессы можно органично описать в виде \gls{observable}, однако бывают случаи, когда процесс является непрерывным и интерактивным длительное время, требует промежуточного сохранения состояния. Специально для построения реактивных систем с мемоизацией состояния и наличием обратной связи был разработан паттерн \emph{RxFeedback}, который будет рассмотрен далее.

Частым решением является по прежнему описывать операцию в виде потока(например, запрос в сеть), сохранить его результат в обычную переменную(производя правильные синхронизации потоков при чтении/записи) и дальнейшем использовании этого значения для создания новых \gls{observable}. Подход плох необходимостью разрывать поток и постоянной заботой о проблемах синхронизации. За время разработки приложения появился паттерн, который отлично ложился в дизайн большинства модулей, не связанных с пользовательским интерфейсом.
Самым простым способом рассмотреть подход является решение проблемы, для иллюстрации паттерна я выбрал проблему постраничного запроса данных из сети(получение поисковых результатов из \gls{api} GitHub).

Github возвращает результат поиска в виде списка подходящих под запрос сущностей и опциональной ссылки на следующую страницу. Следовательно, когда от пользователя поступит запрос на получение следующей страницы -- приложению потребуется забрать результат прошлого поиска, вычислить адрес для новой страницы результатов и отправить запрос(точнее делегировать запрос одному из доступных воркеров). Также система должна быть способна уведомить UI об изменениях, статусе выполнения запроса, отбрасывать пользовательские действия, ведущие к старту уже выполняющегося запроса.
Одним из нескольких элементов архитектуры является состояние. Во время разработки стало очевидно, что состояние должно хранить в себе всю информацию(как данные, так и утилитарную), поэтому состояние поиска можно представить в виде листинга \ref{sec:development:arch:ios:rxfeedback:example:state}.

\begin{code}
  \inputminted{swift}{inc/src/rx-feedback-state.swift}
   \caption{Пример состояния паттерна RxFeedback}
   \label{sec:development:arch:ios:rxfeedback:example:state}
\end{code}

Второй составляющей является набор эвентов(по своей сути, у системы есть набор входящих данных - эвенты и выходящих - вычисление обновлённого состояния), к ним можно отнести:

\begin{itemize}
  \item пользователь запросил новые данные;
  \item получен очередной результат поиска;
  \item получена ошибка при выполнении запроса.
\end{itemize}

Часто результаты операций упаковываются в тип Result, позволяя группировать входящие сообщения и типизировать ошибку, однако для простых примеров бывает удобнее разнести успешный результат выполнения операции и ошибку на два разных события. В листинге \ref{sec:development:arch:ios:rxfeedback:example:event} представлен пример описания входящих событий. Чаще всего они описываются в виде перечисления.

\begin{code}
  \inputminted{swift}{inc/src/rx-feedback-event.swift}
   \caption{Пример события паттерна RxFeedback}
   \label{sec:development:arch:ios:rxfeedback:example:event}
\end{code}

Следующей компонентой является тип, чья обязанность объяснить системе как изменять состояние для каждого конкретного события. Обычно это тип, который имеет метод \mintinline{swift}{func create(input: Input) -> (State) -> State}, принимающий событие и возвращающий метод, каким-то образом модифицирующий состояние. Такой подход позволяет создать много небольших чистых функций, которые принимают состояние, определённым образом его меняют и возвращают результат. Часто для модификации состояния используются линзы, позволяя сделать тип состояния полностью неизменяемым, но они не являются обязательными для имплементации паттерна, поэтому я не буду их использовать в примерах. В листинге \ref{sec:development:arch:ios:rxfeedback:example:mutator} приведён пример обработки одного события. Оператор \(>>>\) является композицией функций, метод resetLoopVariables необходим для поддержания консистентного состояния между вызовами(очищает переменные, которые используются для одноразовой передачи данных).

\begin{code}
  \inputminted{swift}{inc/src/rx-feedback-state-mutator.swift}
   \caption{Пример события паттерна RxFeedback}
   \label{sec:development:arch:ios:rxfeedback:example:mutator}
\end{code}

Имея данный набор компонент уже можно собрать систему, однако для её корректной работы необходимы сущности, выполняющие работу по запросу из состояния. Обычно такие сущности внедряются при помощи Dependency Injection в тип RxFeedback, в нашем случае необходима сущность, способная отправлять запросы в \gls{api} GitHub по требованию, представленная в листинге \ref{sec:development:arch:ios:rxfeedback:example:worker}. В листинге тип возвращает \mintinline{swift}{Observable<Event>}, но обычно возвращается \mintinline{swift}{Observable<Result<Event, Error>>}.

\begin{code}
  \inputminted{swift}{inc/src/rx-feedback-worker.swift}
   \caption{Пример Worker паттерна RxFeedback}
   \label{sec:development:arch:ios:rxfeedback:example:worker}
\end{code}

Для имплементации остаётся только объединить созданные ранее компоненты, что б получить следующий поток:

\begin{itemize}
  \item тип имеет вход вида \mintinline{swift}{AnyObserver<Event>};
  \item все сообщения приводятся к одной последовательной очереди;
  \item входящее сообщение превращается в функцию изменения состояния;
  \item функция применяется к предыдущему состоянию;
  \item результат является новым состоянием и доступен всем подписчикам;
  \item тип, отвечающий за выполнение работы оповещается о новом запросе(если такой имеется);
  \item результат работы возвращается на вход системы.
\end{itemize}

В листинге \ref{sec:development:arch:ios:rxfeedback:example:initial-state} представлена функция для генерации начального состояния системы, а в листинге \ref{sec:development:arch:ios:rxfeedback:example:composition} все компоненты связываются в единый поток.

\begin{code}
  \inputminted{swift}{inc/src/rx-feedback-initial-state.swift}
   \caption{Начальное состояние для паттерна RxFeedback}
   \label{sec:development:arch:ios:rxfeedback:example:initial-state}
\end{code}

\begin{code}
  \inputminted{swift}{inc/src/rx-feedback-composition.swift}
   \caption{Организация потока паттерна RxFeedback}
   \label{sec:development:arch:ios:rxfeedback:example:composition}
\end{code}

Все листинги в этом разделе были приведены в качестве примеров, в настоящей реализации следует обрабатывать ошибки, использовать линзы, Result, правильно проектировать состояние(например, постоянное копирование больших структур сильно замедляет работу приложения).
